{
  config,
  lib,
  pkgs,
  hostConfig,
  ...
}: {
  config = lib.mkIf config.modules.system.containers.enable {
    # SSL/TLS configuration handled by modules.system.ssl

    # Enable Docker daemon
    virtualisation.docker = {
      enable = true;
      enableOnBoot = false; # Disabled for boot performance - start on-demand

      # Container daemon configuration
      daemon.settings = {
        # Performance optimizations
        "storage-driver" = "overlay2";
        "log-driver" = "json-file";
        "log-opts" = {
          "max-size" = "10m";
          "max-file" = "3";
        };

        # DNS configuration for reliable connectivity
        "dns" = ["8.8.8.8" "8.8.4.4"];

        # Network settings
        "userland-proxy" = false;
        "live-restore" = false;
      };
    };

    # Merged systemd configuration
    systemd = {
      # Disable Docker socket activation for boot performance
      sockets.docker = {
        wantedBy = lib.mkForce [];
      };

      # Configure systemd Docker service with SSL from centralized config
      services.docker = {
        # Explicitly disable auto-start at boot
        wantedBy = lib.mkForce [];

        environment =
          config.modules.system.ssl.helpers.dockerEnv
          // {
            # Docker daemon configuration
            DOCKER_TLS_VERIFY = "0"; # Use Unix socket
            GOPROXY = "direct";
            DOCKER_CONFIG = "/etc/docker";
          };

        # Certificate setup from centralized config
        preStart = ''
          ${config.modules.system.ssl.helpers.dockerCertSetup}

                  # Create simplified Docker daemon configuration (remove manual daemon.json creation)
                  # NixOS will generate the proper daemon.json from our daemon.settings configuration
                  echo "Docker daemon configuration will be generated by NixOS from daemon.settings"

                  # Ensure Docker can access certificate files with proper permissions
                  chown root:docker /etc/docker/certs.d/ || true
                  chmod 755 /etc/docker/certs.d/ || true

                  # Create Docker registry-specific certificate configuration
                  # This is the proper way to configure registry certificates for Docker
                  for registry in "registry-1.docker.io" "index.docker.io" "docker.io" "auth.docker.io"; do
                    if [ -d "/etc/docker/certs.d/$registry" ]; then
                      chown root:docker "/etc/docker/certs.d/$registry" || true
                      chmod 755 "/etc/docker/certs.d/$registry" || true
                      if [ -f "/etc/docker/certs.d/$registry/ca.crt" ]; then
                        chown root:docker "/etc/docker/certs.d/$registry/ca.crt" || true
                        chmod 644 "/etc/docker/certs.d/$registry/ca.crt" || true
                      fi
                    fi
                  done

                  # Test Docker registry connectivity and certificate validation
                  echo "Testing Docker registry connectivity..."
                  if timeout 10s curl -sS https://registry-1.docker.io/v2/ >/dev/null 2>&1; then
                    echo "✅ Docker registry connectivity verified"
                  else
                    echo "⚠️  Docker registry connectivity issue - testing with explicit certificates..."
                    # Test with explicit certificate bundle
                    if timeout 10s curl --cacert ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt -sS https://registry-1.docker.io/v2/ >/dev/null 2>&1; then
                      echo "✅ Docker registry works with explicit certificates"
                    else
                      echo "❌ Docker registry connectivity failed - may need proxy configuration"
                    fi
                  fi

                  # Comprehensive activation verification for Docker and Home Manager
                  echo "=== Activation Verification ==="

                  # Verify Docker daemon.json syntax before Docker starts
                  if [ -f "/nix/store"*"-daemon.json" ]; then
                    DAEMON_JSON=$(find /nix/store -name "*daemon.json" -type f | head -1)
                    if [ -n "$DAEMON_JSON" ]; then
                      echo "Validating Docker daemon.json syntax..."
                      if python3 -m json.tool "$DAEMON_JSON" >/dev/null 2>&1; then
                        echo "✅ Docker daemon.json syntax is valid"
                      else
                        echo "❌ Docker daemon.json syntax error detected"
                        python3 -m json.tool "$DAEMON_JSON" || true
                      fi
                    fi
                  fi

                  # Create activation status tracking
                  echo "Creating activation status tracking..."
                  mkdir -p /var/lib/nixos
                  echo "$(date): Docker preStart activation initiated" >> /var/lib/nixos/activation.log

                  # Ensure /usr/local/bin directory exists
                  mkdir -p /usr/local/bin

                  # Set up post-activation verification script
                  cat > /usr/local/bin/verify-activation << 'VERIFY_EOF'
          #!/bin/bash
          echo "=== NixOS Configuration Activation Verification ==="
          echo "Timestamp: $(date)"
          echo

          # Check system activation status
          echo "1. System Activation Status:"
          if systemctl is-system-running >/dev/null 2>&1; then
            echo "   ✅ System is running normally"
          else
            SYSTEM_STATE=$(systemctl is-system-running 2>/dev/null || echo "unknown")
            echo "   ⚠️  System state: $SYSTEM_STATE"
          fi

          # Check Docker service
          echo "2. Docker Service Status:"
          if systemctl is-active docker.service >/dev/null 2>&1; then
            echo "   ✅ Docker service is active"
          else
            echo "   ❌ Docker service is not active"
            echo "   Status: $(systemctl is-active docker.service 2>/dev/null || echo 'failed')"
            echo "   Recent logs:"
            journalctl -u docker.service --no-pager -n 3 --quiet 2>/dev/null || echo "   No logs available"
          fi

          # Check Home Manager activation
          echo "3. Home Manager Status:"
          HM_SERVICE="home-manager-schausberger.service"
          if systemctl is-active $HM_SERVICE >/dev/null 2>&1; then
            echo "   ✅ Home Manager service is active"
          elif systemctl show $HM_SERVICE --property=ActiveState | grep -q "ActiveState=inactive"; then
            if systemctl show $HM_SERVICE --property=Result | grep -q "Result=success"; then
              echo "   ✅ Home Manager activation completed successfully"
            else
              echo "   ❌ Home Manager activation failed"
              echo "   Status: $(systemctl show $HM_SERVICE --property=Result --value)"
            fi
          else
            echo "   ⚠️  Home Manager status unclear"
            echo "   State: $(systemctl is-active $HM_SERVICE 2>/dev/null || echo 'unknown')"
          fi

          # Check for failed units
          echo "4. Failed Units Check:"
          FAILED_UNITS=$(systemctl list-units --failed --no-legend --quiet 2>/dev/null | wc -l)
          if [ "$FAILED_UNITS" -eq 0 ]; then
            echo "   ✅ No failed units detected"
          else
            echo "   ⚠️  $FAILED_UNITS failed unit(s) detected:"
            systemctl list-units --failed --no-legend --quiet 2>/dev/null | head -5 | sed 's/^/     /'
          fi

          echo
          echo "Activation verification completed at $(date)"
          VERIFY_EOF
                  chmod +x /usr/local/bin/verify-activation

                  # Create certificate validation script
                  mkdir -p /usr/local/bin
                  cat > /usr/local/bin/docker-cert-debug << 'EOF'
          #!/bin/bash
          echo "=== Docker Certificate Debug Information ==="
          echo "SSL_CERT_FILE: $SSL_CERT_FILE"
          echo "CURL_CA_BUNDLE: $CURL_CA_BUNDLE"
          echo "DOCKER_CERT_PATH: $DOCKER_CERT_PATH"
          echo "DOCKER_TLS_VERIFY: $DOCKER_TLS_VERIFY"
          echo
          echo "Testing certificate file readability:"
          if [ -r "${config.modules.system.ssl.bundle.standard}" ]; then
            echo "✅ Certificate bundle is readable"
            echo "Certificate count: $(grep -c 'BEGIN CERTIFICATE' ${config.modules.system.ssl.bundle.standard})"
          else
            echo "❌ Certificate bundle is not readable"
          fi
          echo
          echo "Testing Docker registry connectivity:"
          curl -v --connect-timeout 10 https://registry-1.docker.io/v2/ 2>&1 | head -20
          echo
          echo "Testing with explicit certificate bundle:"
          curl -v --cacert ${config.modules.system.ssl.bundle.standard} --connect-timeout 10 https://registry-1.docker.io/v2/ 2>&1 | head -20
          EOF
                  chmod +x /usr/local/bin/docker-cert-debug
        '';
      };

      # Create comprehensive systemd tmpfiles for Docker certificates (WSL2 fix)
      tmpfiles.rules = [
        # Main Docker certificate directories
        "d /etc/docker 0755 root root - -"
        "d /etc/docker/certs.d 0755 root root - -"
        "d /etc/docker/certs.d/registry-1.docker.io 0755 root root - -"
        "d /etc/docker/certs.d/index.docker.io 0755 root root - -"
        "d /etc/docker/certs.d/docker.io 0755 root root - -"
        "d /etc/docker/certs.d/auth.docker.io 0755 root root - -"
        "d /etc/docker/certs.d/production.cloudflare.docker.com 0755 root root - -"

        # Certificate links for Docker registries
        "L+ /etc/docker/certs.d/ca-certificates.crt - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/docker/certs.d/ca.pem - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/docker/certs.d/cert.pem - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/docker/certs.d/key.pem - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/docker/certs.d/registry-1.docker.io/ca.crt - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/docker/certs.d/index.docker.io/ca.crt - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/docker/certs.d/docker.io/ca.crt - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/docker/certs.d/auth.docker.io/ca.crt - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/docker/certs.d/production.cloudflare.docker.com/ca.crt - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"

        # General certificate bundle locations
        "L+ /etc/ssl/certs/ca-certificates.crt - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
        "L+ /etc/ssl/certs/ca-bundle.crt - - - - ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
      ];

      # Systemd service to prepare act-compatible containers with certificates
      services.act-cert-setup = {
        description = "Prepare act containers with proper certificate configuration";
        # Disabled at boot - run manually when needed: systemctl start act-cert-setup
        wantedBy = lib.mkForce [];
        # No Docker dependency - just creates directories and symlinks
        path = with pkgs; [openssl coreutils];

        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
          User = "root";
        };

        script = ''
          # Create certificate directories for act runner environment
          mkdir -p /etc/act-certificates
          mkdir -p /usr/local/share/ca-certificates

          # Link NixOS certificates for act
          if [ ! -f /etc/act-certificates/ca-certificates.crt ]; then
            ln -sf ${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt /etc/act-certificates/ca-certificates.crt
          fi

          # Ensure proper permissions
          chmod 755 /etc/act-certificates
          chmod 644 /etc/act-certificates/ca-certificates.crt || true

          echo "✅ Act certificate setup completed"
        '';
      };
    };

    # SSL/TLS configuration handled by modules.system.ssl
    # Docker-specific environment variables
    environment.variables = {
      # Docker connection via Unix socket (not TLS)
      DOCKER_HOST = "unix:///var/run/docker.sock";
    };

    # Add user to docker group
    users.users.${hostConfig.user}.extraGroups = ["docker"];

    # System packages for container support (cacert handled by ssl-config)
    environment.systemPackages = with pkgs; [
      docker-compose # Docker Compose tool
      openssl # SSL/TLS toolkit for certificate debugging
      curl # For testing registry connectivity
    ];

    # Install act (GitHub Actions runner) in home packages
    home-manager.users.${hostConfig.user} = {
      home.packages = with pkgs; [
        act # Run your GitHub Actions locally
      ];

      # Add container development aliases
      programs.fish.shellAliases = {
        act-check = "DOCKER_HOST=unix:///var/run/docker.sock DOCKER_TLS_VERIFY=0 act -W .github/workflows/check.yml --pull=false";
        act-debug = "DOCKER_HOST=unix:///var/run/docker.sock DOCKER_TLS_VERIFY=0 act -W .github/workflows/check.yml --verbose --pull=false";
        system-health = "/usr/local/bin/verify-activation && /usr/local/bin/docker-cert-debug";
      };

      # Docker-specific session variables (SSL handled by ssl-config)
      home.sessionVariables = {
        # Docker connection via Unix socket (consistent with system environment)
        DOCKER_HOST = "unix:///var/run/docker.sock";
        GOPROXY = lib.mkDefault "direct";
      };
    };
  };

  options.modules.system.containers = {
    enable = lib.mkEnableOption "container tools (Docker and act)";
  };
}
